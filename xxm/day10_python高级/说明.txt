多进程才是真正的多任务  假如电脑是双核 同时开启两个线程(while True:pass) 两个线程合起来会占满一个核
                                    如果是多进程  会把两个核都占满



---------------------  GIL(只影响线程-同一时间只有一个线程在运行) 锁 ---> Cpython解释器
     使用c语言的解释器  多进程比多线程快  (使用的是多核-线程使用的是单核)

     效率问题:
            计算密集:不带阻塞--多进程效率更高
            IO  密集:带阻塞 -- 多线程/协成 效率高资源消耗少

     GIL缺陷解决:换解释器/换语言(其他线程的执行代码-可以直接调用c的代码)




---------计算:独立显卡  CPU



import导入模块时  将硬盘数据加载到内存中  如果更改硬盘上数据之前导入的模块读取不到更新的部分  得再次import
    import避免重新导入  import 模块 reload





# 代码是不变的  数据在变化   代码是公用的  使用__class__来找到公用

----------------------- with
产生异常进程 死掉
with 上下文 操作的对象必须实现 __enter__ 和 __exit__

with xxx as xx  ：xx是__enter__的返回值
不管产生不产生异常都会调用  __exit__    相当于finally  可用于释放资源